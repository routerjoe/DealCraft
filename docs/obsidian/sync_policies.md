# Obsidian Sync Policies & Conflict Handling

**Version:** 1.0  
**Last Updated:** October 29, 2025 EDT  
**Sprint:** 13 - Obsidian Sync

## Overview

This document defines synchronization policies, conflict resolution strategies, and best practices for integrating the Red River Sales MCP API with Obsidian vault.

**Vault Path:** `/Users/jonolan/Documents/Obsidian Documents/Red River Sales`

## Sync Policy Types

### One-Way Sync (API → Obsidian)

**Use Cases:**
- Opportunity creation from webhooks
- Dashboard generation
- Automated reports
- System-generated content

**Behavior:**
- API is source of truth
- Manual edits discouraged
- Files regenerated on updates
- No conflict detection needed

**Example:** Webhook creates opportunity file
```
API Event → File Write → Obsidian File
(No read-back)
```

### Two-Way Sync (API ↔ Obsidian)

**Use Cases:**
- Manual opportunity enrichment
- Note-taking on opportunities
- Custom metadata additions
- Collaborative editing

**Behavior:**
- Both sides can modify
- Conflict detection required
- Last-write-wins with backup
- Merge strategies needed

**Example:** Sales rep updates opportunity
```
Obsidian Edit → Sync Service → API Update
API Update → Sync Service → Obsidian Update
(Bidirectional)
```

### Read-Only (Generated Content)

**Use Cases:**
- Dataview dashboards
- Calculated metrics
- Aggregated reports
- System summaries

**Behavior:**
- API writes only
- Manual edits overwritten
- Clear regeneration timestamps
- Warning comments in file

**Example:** Dashboard refresh
```markdown
---
generated: true
last_update: 2025-10-29T13:00:00Z
# DO NOT EDIT - This file is automatically generated
---
```

## Conflict Resolution Rules

### Rule 1: Timestamp Comparison

```python
def resolve_conflict(api_version, obsidian_version):
    """Last-write-wins strategy."""
    api_timestamp = api_version['updated_at']
    file_timestamp = obsidian_version['modified_time']
    
    if api_timestamp > file_timestamp:
        return "use_api_version"
    else:
        return "use_obsidian_version"
```

### Rule 2: Backup Before Overwrite

```python
def safe_write(file_path, content):
    """Always backup before overwriting."""
    if os.path.exists(file_path):
        backup_path = f"{file_path}.backup"
        shutil.copy(file_path, backup_path)
    
    write_file(file_path, content)
```

### Rule 3: Manual Resolution for Critical Fields

Certain fields require manual resolution:
- Opportunity stage changes
- Amount modifications
- Close date updates
- Deal owner reassignments

## Dataview Refresh Strategy

### Dashboard Query Pattern

```markdown
# Opportunities Dashboard.md
```dataview
TABLE 
  estimated_amount as "Amount",
  close_date as "Close",
  status as "Status"
FROM "40 Projects/Opportunities"
WHERE triage = false
SORT close_date ASC
\```

**Refresh Methods:**
1. **Manual:** Cmd+P → "Dataview: Force Refresh All Views"
2. **Restart:** Close and reopen Obsidian
3. **File Touch:** Modify and save dashboard file
4. **Plugin Reload:** Disable/enable Dataview plugin

### Base Markdown Update

When updating opportunity files:
```python
# Update frontmatter
yaml_data['updated_at'] = datetime.now().isoformat()

# Preserve manual notes section
if '## Manual Notes' in existing_content:
    manual_notes = extract_section(existing_content, '## Manual Notes')
    new_content += '\n\n' + manual_notes
```

## Path Configuration Management

### Environment Variables

```bash
# .env
OBSIDIAN_VAULT_PATH=/Users/jonolan/Documents/Obsidian Documents/Red River Sales
```

### Config Constants

```python
# mcp/core/config.py
import os

OBSIDIAN_VAULT_PATH = os.getenv(
    "OBSIDIAN_VAULT_PATH",
    "/Users/jonolan/Documents/Obsidian Documents/Red River Sales"
)

# Relative paths (portable)
OPPORTUNITIES_PATH = "40 Projects/Opportunities"
DASHBOARDS_PATH = "50 Dashboards"
TRIAGE_PATH = "40 Projects/Opportunities/Triage"

def get_opportunity_path(fiscal_year=None, triage=False):
    """Construct opportunity path safely."""
    base = os.path.join(OBSIDIAN_VAULT_PATH, OPPORTUNITIES_PATH)
    if triage:
        return os.path.join(base, "Triage")
    elif fiscal_year:
        return os.path.join(base, fiscal_year)
    return base
```

### Path Construction Rules

✅ **Good:**
```python
from mcp.core.config import OBSIDIAN_VAULT_PATH, OPPORTUNITIES_PATH
path = os.path.join(OBSIDIAN_VAULT_PATH, OPPORTUNITIES_PATH, "FY26", "opp.md")
```

❌ **Bad:**
```python
path = "/Users/jonolan/Documents/Obsidian Documents/Red River Sales/40 Projects/Opportunities/FY26/opp.md"
```

## Backup & Restore Procedures

### Automatic Backup

```python
def backup_before_write(file_path):
    """Create timestamped backup."""
    if not os.path.exists(file_path):
        return
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_dir = os.path.join(OBSIDIAN_VAULT_PATH, ".backups")
    os.makedirs(backup_dir, exist_ok=True)
    
    backup_name = f"{os.path.basename(file_path)}.{timestamp}.backup"
    backup_path = os.path.join(backup_dir, backup_name)
    
    shutil.copy(file_path, backup_path)
    logger.info(f"Backed up {file_path} to {backup_path}")
```

### Manual Restore

```bash
# List backups
ls -la "obsidian/.backups"

# Restore from backup
cp "obsidian/.backups/opportunity.md.20251029_130000.backup" \
   "obsidian/40 Projects/Opportunities/FY26/opportunity.md"
```

## File Locking

### Lock File Strategy

```python
import fcntl

def write_with_lock(file_path, content):
    """Acquire file lock before writing."""
    lock_path = f"{file_path}.lock"
    
    with open(lock_path, 'w') as lock_file:
        fcntl.flock(lock_file.fileno(), fcntl.LOCK_EX)
        try:
            with open(file_path, 'w') as f:
                f.write(content)
        finally:
            fcntl.flock(lock_file.fileno(), fcntl.LOCK_UN)
    
    os.remove(lock_path)
```

## Conflict Scenarios & Resolution

### Scenario 1: Webhook Update During Manual Edit

**Situation:** Sales rep editing opportunity while webhook arrives

**Resolution:**
1. Detect file modified time > last sync
2. Create backup of manual edits
3. Apply webhook data to separate file
4. Notify user of conflict
5. Provide merge UI (future)

### Scenario 2: Dashboard Refresh with Manual Edits

**Situation:** User manually edits dashboard markdown

**Resolution:**
1. Dashboards are read-only (documented)
2. Overwrite with warning in logs
3. Previous version in backups
4. Recommend using separate note for custom queries

### Scenario 3: Concurrent API Writes

**Situation:** Multiple webhooks for same opportunity

**Resolution:**
1. File-level locking (fcntl)
2. Retry with exponential backoff
3. Log concurrent access
4. Last write wins

## Best Practices

### For API Developers

1. **Always use config constants** for paths
2. **Never hardcode** home directory paths
3. **Backup before write** for existing files
4. **Use atomic writes** (temp file + rename)
5. **Log all file operations** with timestamps

### For Sales Team

1. **Don't edit dashboards** - they're regenerated
2. **Add notes** in "## Manual Notes" section
3. **Check updated_at** timestamp before editing
4. **Report conflicts** to development team
5. **Use tags** for custom organization

### For System Administrators

1. **Set OBSIDIAN_VAULT_PATH** in environment
2. **Monitor backup directory** size
3. **Schedule backup cleanup** (> 30 days)
4. **Test restore procedures** quarterly
5. **Document custom sync** configurations

## Troubleshooting

### Issue: Dataview Not Updating

**Solution:**
1. Force refresh: `Cmd+P` → "Dataview: Force Refresh"
2. Check file timestamps
3. Restart Obsidian
4. Verify Dataview plugin enabled

### Issue: Files in Wrong Directory

**Solution:**
1. Check `OBSIDIAN_VAULT_PATH` environment variable
2. Verify path construction in code
3. Review logs for path resolution
4. Run path validation tests

### Issue: Conflict Not Detected

**Solution:**
1. Check file modified timestamps
2. Verify backup creation
3. Review lock file behavior
4. Enable debug logging

## Future Enhancements

Planned for post-Sprint 13:
- **Real-time file watching** - inotify/FSEvents
- **AI-powered conflict resolution** - Smart merges
- **Version control integration** - Git-based history
- **Collaborative editing** - Operational transforms
- **Mobile sync support** - Obsidian Sync integration

---

**Related Documentation:**
- [Sprint 13 Plan](../sprint_plan.md)
- [Obsidian Integration](README.md)
- [API Configuration](../../api/configuration.md)